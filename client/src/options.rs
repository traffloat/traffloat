//! Client settings

use arcstr::ArcStr;
use serde::{Deserialize, Serialize};
use yew::services::storage;

use traffloat::def::{cargo, gas, liquid};

/// The localStorage key for options
pub const STORAGE_KEY: &str = "traffloat:game_options";

/// All settings for the client, serialized in `localStorage`.
#[derive(Debug, Clone, Serialize, Deserialize, getset::Getters, getset::MutGetters)]
pub struct Options {
    /// Graphics settings.
    #[getset(get = "pub", get_mut = "pub")]
    graphics: Graphics,
}

/// Graphics settings.
#[derive(
    Debug, Clone, Serialize, Deserialize, getset::CopyGetters, getset::Getters, getset::MutGetters,
)]
pub struct Graphics {
    /// Whether stars should be rendered.
    #[getset(get_copy = "pub", get_mut = "pub")]
    render_stars: bool,
    /// Whether axis reticle should be rendered.
    #[getset(get_copy = "pub", get_mut = "pub")]
    render_reticle: bool,
    /// Whether debug info should be rendered.
    #[getset(get_copy = "pub", get_mut = "pub")]
    render_debug_info: bool,
    /// Options for node rendering.
    #[getset(get = "pub", get_mut = "pub")]
    node: Node,
    /// Options for edge rendering.
    #[getset(get = "pub", get_mut = "pub")]
    edge: Edge,
}

/// Node rendering settings.
#[derive(Debug, Clone, Serialize, Deserialize, getset::CopyGetters, getset::Getters)]
pub struct Node {
    /// Whether nodes should be rendered.
    #[getset(get_copy = "pub", get_mut = "pub")]
    render: bool,
    /// The base color to draw upon.
    #[getset(get_copy = "pub", get_mut = "pub")]
    base: [f32; 3],
    /// The texture variant name to draw with, or `None` if textures should not be used.
    #[getset(get = "pub", get_mut = "pub")]
    texture: Option<ArcStr>,
    /// A color filter based on total cargo storage size of a type in the node,
    /// relative to the largest rendered storage.
    #[getset(get = "pub", get_mut = "pub")]
    cargo: Option<(cargo::TypeId, ColorMap)>,
    /// A color filter based on total liquid storage size of a type in the node,
    /// relative to the largest rendered storage.
    #[getset(get = "pub", get_mut = "pub")]
    liquid: Option<(liquid::TypeId, ColorMap)>,
    /// A color filter based on total gas storage size of a type in the node,
    /// relative to the largest rendered storage.
    #[getset(get = "pub", get_mut = "pub")]
    gas: Option<(gas::TypeId, ColorMap)>,
    /// A color filter based on electricity used/generated by the node.
    /// The colormap is unevenly scaled into [0, 0.5] and [0.5, 1],
    /// the former mapped to maximum consumption and
    /// the latter mapped to the maximum production.
    #[getset(get_copy = "pub", get_mut = "pub")]
    electricity_usage: Option<ColorMap>,
    /// A color filter based on electricity surplus of the electricity grid
    /// that the node belongs to, relative to the largest electricity grid.
    #[getset(get_copy = "pub", get_mut = "pub")]
    electricity_surplus: Option<ColorMap>,
    /// A color filter based on sunlight received by the node,
    /// relative to the largest rendered brightness.
    #[getset(get_copy = "pub", get_mut = "pub")]
    brightness: Option<ColorMap>,
    /// A color filter based on the percentage hitpoint of the node,
    /// relative to the largest rendered percentage hitpoint.
    #[getset(get_copy = "pub", get_mut = "pub")]
    hitpoint: Option<ColorMap>,
}

/// Edge rendering settings.
#[derive(Debug, Clone, Serialize, Deserialize, getset::CopyGetters)]
pub struct Edge {
    /// Whether nodes should be rendered.
    #[getset(get_copy = "pub", get_mut = "pub")]
    render: bool,
    /// The base color to draw upon.
    #[getset(get_copy = "pub", get_mut = "pub")]
    base: [f32; 3],
    /// A color filter based on total cargo transfer rate of a type across the edge,
    /// relative to the largest rendered rate.
    #[getset(get = "pub", get_mut = "pub")]
    cargo: Option<(cargo::TypeId, ColorMap)>,
    /// A color filter based on total liquid storage size of a type in the edge,
    /// relative to the largest rendered rate.
    #[getset(get = "pub", get_mut = "pub")]
    liquid: Option<(liquid::TypeId, ColorMap)>,
    /// A color filter based on total gas storage size of a type in the edge,
    /// relative to the largest rendered rate.
    #[getset(get = "pub", get_mut = "pub")]
    gas: Option<(gas::TypeId, ColorMap)>,
    /// A color filter based on electric current transferred across the edge,
    /// relative to the largest rendered current.
    #[getset(get_copy = "pub", get_mut = "pub")]
    electricity_current: Option<ColorMap>,
    /// A color filter based on electricity surplus of the electricity grid
    /// that the edge belongs to, relative to the largest electricity grid.
    #[getset(get_copy = "pub", get_mut = "pub")]
    electricity_surplus: Option<ColorMap>,
    // /// A color filter based on sunlight received by the edge,
    // /// relative to the largest rendered brightness.
    // brightness: Option<ColorMap>,
    /// A color filter based on the percentage hitpoint of the edge,
    /// relative to the largest rendered percentage hitpoint.
    #[getset(get_copy = "pub", get_mut = "pub")]
    hitpoint: Option<ColorMap>,
}

/// A function mapping a scalar [0, 1] to a color [0, 1]^3.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum ColorMap {
    /// A constant color value.
    Monochrome([f32; 3]),
    /// A linear color value.
    Linear([f32; 3]),
    /// A colormap formed by three trapeziums.
    Trapeziums([Trapezium; 3]),
}

/// A trapezium function.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, derive_new::new, getset::CopyGetters)]
#[getset(get_copy = "pub")]
pub struct Trapezium {
    /// The scalar value at which this channel starts increasing.
    min_start: f32,
    /// The scalar value at which this channel reaches the maximum.
    max_start: f32,
    /// The scalar value at which this channel starts decreasing.
    max_end: f32,
    /// The scalar value at which this channel reaches zero.
    min_end: f32,
    /// The maximum height of the trapezium.
    maximum: f32,
}

impl Options {
    /// This method deliberately does not implement [`Default`]
    /// to avoid accidentally overwriting the default initialization.
    pub fn default() -> Self {
        Self {
            graphics: Graphics {
                render_stars: true,
                render_reticle: true,
                render_debug_info: true,
                node: Node {
                    render: true,
                    base: [1., 1., 1.],
                    texture: Some(arcstr::literal!("fancy")),
                    cargo: None,
                    liquid: None,
                    gas: None,
                    electricity_usage: None,
                    electricity_surplus: None,
                    brightness: Some(ColorMap::Linear([1., 1., 1.])),
                    hitpoint: None,
                },
                edge: Edge {
                    render: true,
                    base: [0.3, 0.5, 0.8],
                    cargo: None,
                    liquid: None,
                    gas: None,
                    electricity_current: None,
                    electricity_surplus: None,
                    hitpoint: None,
                },
            },
        }
    }
}

/// Sets up legion ECS.
pub fn setup_ecs(setup: traffloat::SetupEcs) -> traffloat::SetupEcs {
    let storage =
        storage::StorageService::new(storage::Area::Local).expect("Failed to fetch localStorage");
    let yew::format::Json(options) = storage.restore(STORAGE_KEY);
    let options: Options = options.unwrap_or_else(|_| Options::default());
    setup.resource(options)
}
