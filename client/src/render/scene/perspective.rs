use arcstr::ArcStr;
use traffloat::def::{cargo, gas, liquid};

/// Display options for the scene.
#[derive(Debug, getset::Getters, getset::CopyGetters, getset::Setters)]
pub struct Perspective {
    /// Display options for nodes.
    nodes: NodePerspective,
    /// Display options for edges.
    edges: EdgePerspective,
}

impl Default for Perspective {
    fn default() -> Self {
        Self {
            nodes: NodePerspective {
                render: true,
                base: [1., 1., 1.],
                texture: Some(arcstr::literal!("fancy")),
                cargo: None,
                liquid: None,
                gas: None,
                electricity_usage: None,
                electricity_surplus: None,
                brightness: Some(ColorMap::Linear([1., 1., 1.])),
                hitpoint: None,
            },
            edges: EdgePerspective {
                render: true,
                base: [0.3, 0.5, 0.8],
                cargo: None,
                liquid: None,
                gas: None,
                electricity_current: None,
                electricity_surplus: None,
                hitpoint: None,
            },
        }
    }
}

/// Display options for nodes.
#[derive(Debug, getset::Getters, getset::CopyGetters, getset::Setters)]
pub struct NodePerspective {
    /// Whether nodes should be rendered.
    #[getset(get_copy = "pub", set = "pub")]
    render: bool,
    /// The base color to draw upon.
    #[getset(get_copy = "pub", set = "pub")]
    base: [f32; 3],
    /// The texture variant name to draw with, or `None` if textures should not be used.
    #[getset(get = "pub", set = "pub")]
    texture: Option<ArcStr>,
    /// A color filter based on total cargo storage size of a type in the node,
    /// relative to the largest rendered storage.
    cargo: Option<(cargo::TypeId, ColorMap)>,
    /// A color filter based on total liquid storage size of a type in the node,
    /// relative to the largest rendered storage.
    liquid: Option<(liquid::TypeId, ColorMap)>,
    /// A color filter based on total gas storage size of a type in the node,
    /// relative to the largest rendered storage.
    gas: Option<(gas::TypeId, ColorMap)>,
    /// A color filter based on electricity used/generated by the node.
    /// The colormap is unevenly scaled into [0, 0.5] and [0.5, 1],
    /// the former mapped to maximum consumption and
    /// the latter mapped to the maximum production.
    electricity_usage: Option<ColorMap>,
    /// A color filter based on electricity surplus of the electricity grid
    /// that the node belongs to, relative to the largest electricity grid.
    electricity_surplus: Option<ColorMap>,
    /// A color filter based on sunlight received by the node,
    /// relative to the largest rendered brightness.
    brightness: Option<ColorMap>,
    /// A color filter based on the percentage hitpoint of the node,
    /// relative to the largest rendered percentage hitpoint.
    hitpoint: Option<ColorMap>,
}

/// Display options for edges.
#[derive(Debug, getset::Getters, getset::CopyGetters, getset::Setters)]
pub struct EdgePerspective {
    /// Whether nodes should be rendered.
    #[getset(get_copy = "pub", set = "pub")]
    render: bool,
    /// The base color to draw upon.
    #[getset(get_copy = "pub", set = "pub")]
    base: [f32; 3],
    /// A color filter based on total cargo transfer rate of a type across the edge,
    /// relative to the largest rendered rate.
    cargo: Option<(cargo::TypeId, ColorMap)>,
    /// A color filter based on total liquid storage size of a type in the edge,
    /// relative to the largest rendered rate.
    liquid: Option<(liquid::TypeId, ColorMap)>,
    /// A color filter based on total gas storage size of a type in the edge,
    /// relative to the largest rendered rate.
    gas: Option<(gas::TypeId, ColorMap)>,
    /// A color filter based on electric current transferred across the edge,
    /// relative to the largest rendered current.
    electricity_current: Option<ColorMap>,
    /// A color filter based on electricity surplus of the electricity grid
    /// that the edge belongs to, relative to the largest electricity grid.
    electricity_surplus: Option<ColorMap>,
    // /// A color filter based on sunlight received by the edge,
    // /// relative to the largest rendered brightness.
    // brightness: Option<ColorMap>,
    /// A color filter based on the percentage hitpoint of the edge,
    /// relative to the largest rendered percentage hitpoint.
    hitpoint: Option<ColorMap>,
}

/// A function mapping a scalar [0, 1] to a color [0, 1]^3.
#[derive(Debug)]
pub enum ColorMap {
    /// A constant color value.
    Monochrome([f32; 3]),
    /// A linear color value.
    Linear([f32; 3]),
    /// A colormap formed by three trapeziums.
    Trapeziums([Trapezium; 3]),
}

/// A trapezium function.
#[derive(Debug, derive_new::new, getset::CopyGetters)]
#[getset(get_copy = "pub")]
pub struct Trapezium {
    /// The maximum height of the trapezium.
    maximum: f32,
    /// The scalar value at which this channel starts increasing.
    min_start: f32,
    /// The scalar value at which this channel reaches the maximum.
    max_start: f32,
    /// The scalar value at which this channel starts decreasing.
    max_end: f32,
    /// The scalar value at which this channel reaches zero.
    min_end: f32,
}
